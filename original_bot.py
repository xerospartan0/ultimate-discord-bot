import os
import io
import base64
import time
import asyncio
import discord
from discord import app_commands
from dotenv import load_dotenv
from openai import AsyncOpenAI

load_dotenv()

DISCORD_TOKEN = os.getenv("DISCORD_TOKEN")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
LOG_CHANNEL_ID = int(os.getenv("LOG_CHANNEL_ID")) if os.getenv("LOG_CHANNEL_ID") else None
WELCOME_CHANNEL_ID = int(os.getenv("WELCOME_CHANNEL_ID")) if os.getenv("WELCOME_CHANNEL_ID") else None

# Initialize async OpenAI client
client_ai = AsyncOpenAI(api_key=OPENAI_API_KEY)

# Simple in-memory rate limiter: allow 5 actions per 30 seconds
RATE_LIMIT_COUNT = 5
RATE_LIMIT_PERIOD = 30
user_timestamps = {}

# Basic moderation wordlist (extendable)
BANNED_WORDS = {"badword1", "badword2"}  # replace with real words

class BotClient(discord.Client):
    def __init__(self):
        intents = discord.Intents.default()
        intents.members = True
        intents.message_content = True
        super().__init__(intents=intents)
        self.tree = app_commands.CommandTree(self)

    async def setup_hook(self):
        # Register commands to guild if you want faster sync (optional)
        await self.tree.sync()

    async def on_ready(self):
        print(f"Bot is online as {self.user}")

bot = BotClient()

# ---------- Utilities ----------

def is_rate_limited(user_id: int) -> bool:
    now = time.time()
    timestamps = user_timestamps.get(user_id, [])
    # keep only recent
    timestamps = [t for t in timestamps if now - t < RATE_LIMIT_PERIOD]
    if len(timestamps) >= RATE_LIMIT_COUNT:
        user_timestamps[user_id] = timestamps
        return True
    timestamps.append(now)
    user_timestamps[user_id] = timestamps
    return False

async def log_message(content: str):
    if LOG_CHANNEL_ID:
        ch = bot.get_channel(LOG_CHANNEL_ID)
        if ch:
            await ch.send(content)

async def safe_openai_chat(prompt: str, max_tokens: int = 150):
    # Wrap OpenAI call with timeout and error handling
    try:
        resp = await asyncio.wait_for(
            client_ai.chat.completions.create(
                model="gpt-4o-mini",
                messages=[{"role": "system", "content": "You are a helpful Discord assistant."},
                          {"role": "user", "content": prompt}],
                max_tokens=max_tokens,
                temperature=0.7,
            ),
            timeout=20,
        )
        return resp.choices[0].message.content
    except asyncio.TimeoutError:
        return "Sorry, the AI took too long to respond. Try again." 
    except Exception as e:
        await log_message(f"OpenAI error: {e}")
        return "An error occurred while contacting the AI."

async def generate_image(prompt: str):
    try:
        resp = await client_ai.images.generate(
            model="gpt-image-1",
            prompt=prompt,
            size="1024x1024"
        )
        # The SDK returns base64 in data[0].b64_json
        b64 = resp.data[0].b64_json
        img_bytes = base64.b64decode(b64)
        return img_bytes
    except Exception as e:
        await log_message(f"Image generation error: {e}")
        return None

# ---------- Slash commands ----------

@bot.tree.command(name="help", description="Show bot help")
async def help_command(interaction: discord.Interaction):
    embed = discord.Embed(title="Bot Help", description="Available commands and features")
    embed.add_field(name="/help", value="Shows this help message", inline=False)
    embed.add_field(name="/image <prompt>", value="Generate an image from prompt", inline=False)
    embed.add_field(name="/summarize <text>", value="Summarize a text", inline=False)
    embed.add_field(name="/translate <text> <lang>", value="Translate text to language (e.g., en, es)", inline=False)
    embed.add_field(name="/suggest_nick <user>", value="Suggest a nickname using AI", inline=False)
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="image", description="Generate an image with AI")
@app_commands.describe(prompt="Image prompt")
async def image_cmd(interaction: discord.Interaction, prompt: str):
    await interaction.response.defer()
    if is_rate_limited(interaction.user.id):
        await interaction.followup.send("You're doing that too much. Please wait a bit.")
        return
    img_bytes = await generate_image(prompt)
    if not img_bytes:
        await interaction.followup.send("Failed to generate image.")
        return
    file = discord.File(io.BytesIO(img_bytes), filename="image.png")
    await interaction.followup.send(file=file)
    await log_message(f"Image generated by {interaction.user} - prompt: {prompt}")

@bot.tree.command(name="summarize", description="Summarize the given text")
@app_commands.describe(text="Text to summarize")
async def summarize_cmd(interaction: discord.Interaction, text: str):
    await interaction.response.defer()
    if is_rate_limited(interaction.user.id):
        await interaction.followup.send("Rate limit hit. Try again later.")
        return
    prompt = f"Summarize this in 3 sentences:\n\n{text}"

{text}"

{text}"
    summary = await safe_openai_chat(prompt, max_tokens=120)
    await interaction.followup.send(summary)
    await log_message(f"Summarize used by {interaction.user}: {text}")

@bot.tree.command(name="translate", description="Translate text to target language")
@app_commands.describe(text="Text to translate", target_lang="Target language code, e.g., en, es")
async def translate_cmd(interaction: discord.Interaction, text: str, target_lang: str):
    await interaction.response.defer()
    if is_rate_limited(interaction.user.id):
        await interaction.followup.send("Rate limit hit. Try again later.")
        return
    prompt = f"Translate the following text to {target_lang} keeping meaning and tone:

{text}"
    translation = await safe_openai_chat(prompt, max_tokens=200)
    await interaction.followup.send(translation)
    await log_message(f"Translate used by {interaction.user}: {text} -> {target_lang}")

@bot.tree.command(name="suggest_nick", description="Suggest a nickname for a user")
@app_commands.describe(user="Member to suggest nickname for")
async def suggest_nick(interaction: discord.Interaction, user: discord.Member):
    await interaction.response.defer()
    if is_rate_limited(interaction.user.id):
        await interaction.followup.send("Rate limit hit. Try again later.")
        return
    prompt = f"Suggest 5 fun, friendly Discord nicknames for a user named {user.display_name}. Keep them short and safe."
    res = await safe_openai_chat(prompt, max_tokens=80)
    await interaction.followup.send(res)
    await log_message(f"Nick suggestion for {user} by {interaction.user}")

# ---------- Events: welcome, moderation, reply detection ----------

@bot.event
async def on_member_join(member: discord.Member):
    if WELCOME_CHANNEL_ID:
        ch = bot.get_channel(WELCOME_CHANNEL_ID)
        if ch:
            await ch.send(f"ðŸŽ‰ Welcome {member.mention}! Enjoy your stay.")

@bot.event
async def on_message(message: discord.Message):
    # Ignore bots
    if message.author.bot:
        return

    # Simple moderation: check banned words
    lowered = message.content.lower()
    if any(bad in lowered for bad in BANNED_WORDS):
        try:
            await message.delete()
            await message.channel.send(f"{message.author.mention}, your message was removed for violating server rules.")
            await log_message(f"Deleted message from {message.author}: {message.content}")
        except Exception:
            pass
        return

    # If the message is a reply to the bot's message -> auto-reply
    if message.reference:
        replied = message.reference.resolved
        if replied and replied.author == bot.user:
            if is_rate_limited(message.author.id):
                await message.reply("You're sending messages too quickly. Please wait a bit.")
                return
            async with message.channel.typing():
                reply_text = await safe_openai_chat(message.content)
                try:
                    await message.reply(reply_text)
                except Exception:
                    await message.channel.send(reply_text)
                await log_message(f"Auto-replied to {message.author}: {message.content}")
            return

    # If the bot is mentioned -> reply in-channel
    if bot.user in message.mentions:
        if is_rate_limited(message.author.id):
            await message.channel.send("You're sending messages too quickly. Please wait a bit.")
            return
        async with message.channel.typing():
            # remove mention from content
            cleaned = ' '.join(w for w in message.content.split() if not w.startswith('<@'))
            res = await safe_openai_chat(cleaned)
            await message.channel.send(res)
            await log_message(f"Mention-replied to {message.author}: {message.content}")
        return

    # Process app commands if any (keeps slash commands working)
    try:
        await bot.process_commands(message)
    except Exception:
        pass

# ---------- Error handling: auto-delete errors and log ----------

@bot.event
async def on_command_error(ctx, error):
    try:
        msg = await ctx.send(f"Error: {error}")
        await asyncio.sleep(8)
        await msg.delete()
    except Exception:
        pass
    await log_message(f"Command error: {error}")

# ---------- Run ----------

if __name__ == '__main__':
    bot.run(DISCORD_TOKEN)
